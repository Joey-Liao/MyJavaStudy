@[toc]

# 1 类的生命周期
类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：：**加载**（Loading）、**验证**（Verification）、**准备**（Preparation）、**解析**（Resolution）、**初始化**（Initialization）、**使用**（Using）和**卸载**（Unloading）。其中，前三个阶段可以统称为**连接**（Linking）。
![在这里插入图片描述](D:\Typora\workspace\JVM\JVM 类的加载过程.assets\cbb9705ec910498499aed023ab5a0b97.png)

# 2 类加载过程
系统加载Class文件的三步：**加载->链接->初始化**。链接过程又可分为三步：**验证->准备->解析**
![在这里插入图片描述](D:\Typora\workspace\JVM\JVM 类的加载过程.assets\fd5a4714f1964f59bf38332f6dafc3ef.png)

## 2.1 加载(通过全类名生成Class对象的过程)
类加载过程的第一步，主要完成下面 3 件事情：
1. 通过**全类名**获取定义此类的**二进制字节流。**
2. 将字节流所代表的静态存储结构**转换**为方法区的运行时数据结构。
3. 在内存中生成一个代表该类的 **Class 对象**，作为方法区这些数据的访问入口。

加载这一步主要是通过我们后面要讲到的 **类加载器** 完成的。类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载由 **双亲委派模型** 决定（不过，我们也能打破由双亲委派模型）。

每个 Java 类都有一个引用指向加载它的 **ClassLoader**。不过，数组类不是通过 ClassLoader 创建的，而是 JVM 在需要的时候自动创建的，数组类通过`getClassLoader()`方法获取 ClassLoader 的时候和该数组的元素类型的 ClassLoader 是一致的。

**加载阶段与连接阶段的部分动作(如一部分字节码文件格式验证动作)是交叉进行的**，加载阶段尚未结束，连接阶段可能就已经开始了。

## 2.2 验证（验证字节流的安全）
验证是连接阶段的第一步，这一阶段的**目的是确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。**


验证阶段主要由**四**个检验阶段组成： 
1. 文件格式验证（Class 文件格式检查）
2. 元数据验证（字节码语义检查）
3. 字节码验证（程序语义检查）
4. 符号引用验证（类的正确性检查）

![在这里插入图片描述](D:\Typora\workspace\JVM\JVM 类的加载过程.assets\af507f32ebf54034a463c80611e29d99.png)
**符号引用验证发生在类加载过程中的解析阶段，具体点说是 JVM 将符号引用转化为直接引用的时候**。符号引用验证的主要目的是确保解析阶段能正常执行，如果无法通过符号引用验证，JVM 会抛出异常





## 2.3 准备（正式为类变量分配内存并设置类变量初始值的阶段）
**准备阶段是正式为类变量分配内存并设置类变量初始值的阶段**，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：

1. 这时候进行**内存分配的仅包括类变量**（ Class Variables ，即**静态变量**，被 static 关键字修饰的变量，只与类相关，因此被称为类变量），而不包括实例变量。**实例变量会在对象实例化时随着对象一块分配在 Java 堆中**。
2. 从概念上讲，类变量所使用的内存都应当在 **方法区** 中进行分配。除了字符串常量池分配在堆中
3. 这里所设置的初始值"通常情况"下是数据类型默认的零值（如 0、0L、null、false 等），比如我们定义了public static int value=111 ，那么 value 变量在准备阶段的初始值就是 0 而不是 111（初始化阶段才会赋值）。**特殊情况**：比如给 value 变量加上了 **final** 关键字public static final int value=111 ，那么准备阶段 value 的值就被赋值为 111。

## 2.4 解析（解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程）
**解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。** 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。

## 2.5 初始化（初始化阶段是执行初始化方法 `<clinit> ()`方法的过程）
**初始化阶段是执行初始化方法 `<clinit> ()`方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。**

> `<clinit> ()`方法是编译之后自动生成的。

对于初始化阶段，**只有主动去使用类才会初始化类**



# 3 类卸载
**卸载类即该类的 Class 对象被 GC**

卸载类需要满足 3 个要求:
1. 该类的所有的**实例对象都已被 GC**，也就是说堆不存在该类的实例对象。
2. 该类**没有**在其他任何地方**被引用**
3. 该类的**类加载器的实例已被 GC**

所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。