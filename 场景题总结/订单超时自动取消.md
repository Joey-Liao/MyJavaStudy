# 订单超时自动取消如何实现？

这个问题的本质是在考察你对**延时任务解决方案**的了解。类似的问题还有:

1. 会议预定成功后，会议开始前30分钟通知所有预定该会议的用户，如何实现?

2. 用户订单完成后未点击收货，10天后自动同意收货，如何实现?

3. 用户发起退款后，三天之内未被处理自动退款给用户，如何实现?

4. .......

**单机延时任务方案**有**Timer** 、 **ScheduledExecutorService** ， **DelayQueue** ， **Spring Task**和**时间轮**，其中最常用也是比较推荐使用的是时间轮。

单机延时任务方案有Timer 、 ScheduledExecutorService . DelayQueue . Spring Task和时间轮，其中最常用也是比较推荐使用的是时间轮。

分布式延时任务的解决方案有**Redis**和**MQ**。实际项目中MQ延时任务用的更多，可以降低业务之间的耦合度。

大部分消息队列，例如RocketMQ、RabbitMQ，都支持**定时/延时**消息。不过，在使用MQ定时/延时消息之前一定要看清楚其使用限制，以免不适合项目需求，例如RocketMQ定时时长最大值默认为24小时且不支持自定义修改、定时精度为秒。





RabbitMQ延迟队列的两种实现方式:

1. RabbitMQ 3.6.x之前我们一般采用**DLX (Dead Letter Exchange，死信队列)+TLL (Time ToLive，过期时间)**。具体的原理是:将消息发送到一个设置了TTL的队列中，当消息过期后，会被转发到另一个设置了DLX的队列中，消费者监听这个DLX队列来获取延迟消息。

2. RabbitMQ 3.6.x开始，RabbitMQ官方提供了延迟队列的**插件**rabbitmq_delayed_message_exchange。这种方式用的更多一些，比较简单方便，解决了DLX+TLL存在的一些问题（后面会提到)。通过这个插件，我们可以声明x-delayed-message类型的Exchange (一种新的交换器类型)，消息发送时指定消息头x-delay 以毫秒为单位将消息进行延迟投递。这个插件支持的最大延迟时间是(2^32)-1毫秒，大约49天。

**DLX+TLL**这种方式存在一些**问题**比如:

1. **存在消息阻塞问题(主要问题)**︰如果设置的是队列统一过期时间放到死信队列，那么就不会有阻塞问题，因为所有的消息都会在同一时间过期，然后被投递到死信队列。但是这种方案也有一个缺点，就是它不能实现不同的延迟时间，所有的消息都必须等待同样的时间才能被消费。如果是设置每条消息的TTL不同，那么可能会出现这阻塞问题。因为过期时间的检测也是从消息队列头部开始的，而队列又遵循先进先出，如果一个过期时间较长的消息在头部的话，可能就会导致阻塞其他过期时间较短的消息。

2. **要为不同的延迟时间创建多个队列**︰我们上面也说了队列统一过期时间可以解决头阻塞问题，但不能实现不同的延迟时间。如果想要实现不同的延迟时间，就需要单独为每一种过期时间创建一个对应的消息队列。如果延迟时间是动态可配置的，那么就需要动态地创建和删除队列。这样会增加系统复杂度、资源消耗和维护难度。而且，并不灵活，如果延迟时间是无规律的，那这种方式也不合适了。
3. **不适合延迟时间较长的任务**:会占用原队列和死信队列的空间。如果消息过期时间太长，那么它们就会在队列中存储很久，占用内存或磁盘空间。

更推荐RabbitMQ延迟队列**插件**这种方式。这种方式中，消息并不会立即进入队列，而是**先把他们保存在Mnesia数据库**(Erlang运行时中自带的一个分布式数据库管理系统，详细介绍可参考Mnesia数据库)中，然后**通过一个定时器去查询需要被投递的消息，再把他们投递到x-delayed-message队列中**。这种方式不存在消息阻塞问题，还可以实现灵活的延迟时间。并且，还避免过期时间太长的消息在队列中堆积，导致占用内存或磁盘空间。

Quartz、Elastic-Job、XXL-JOB和PowerJob这几个是专门用来做分布式调度的框架，也可以实现延时任务，但一般不推荐这么做，它们更适合执行周期性的定时任务。